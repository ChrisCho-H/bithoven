use std::str::FromStr;

grammar;

pub Expr: String = {
    <m:MathExpr> => m.to_string(),
    <a:AssignExpr> => "(".to_owned() + &a.0 + ", " + &a.1 + ")",
};

MathExpr: i64 = {
    <l:MathExpr> "+" <r:Term> => l + r,
    <l:MathExpr> "-" <r:Term> => l - r,
    <t:Term> => t,  // Important: This allows a Term to be an Expr
};

AssignExpr: (String, String) = "let" <Var> "=" <Lit> => (<>).into();

Term: i64 = {
    <f:Factor> => f, // Important: This allows a Factor to be a Term
};

Factor: i64 = {
     <i:Integer> => i,
    "(" <e:MathExpr> ")" => e,
};

Integer: i64 = {
     <n:Num> => n,
     "-" <n:Num> => -n, // Unary minus at the Integer level
}

Num: i64 = <s:r"[0-9]+"> => {
    let integer = i64::from_str(s).unwrap();
    // Number is 32 bit sign magnitude int, except when used as locktime.
    // To determine whether locktime or not is beyond context-free grammar.
    // Can be addressed when context analysis done
    if integer <= i32::MIN as i64 || integer > u32::MAX as i64 {
        panic!("overflow")
    } else {
        integer
    }
};

Var: String = <r"[a-z]"> => <>.chars().next().unwrap().into();

Lit: String = <l:r#""[a-z ]*""#> => l[1..l.len()-1].into();
/*
pub Comm: () = <> => match <> {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
}
*/